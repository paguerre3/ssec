# ssec
Spring Security Compendium


---
Authentication and authorization are two fundamental concepts in software security, often used together but serving distinct purposes:

**1. Authentication** is the **process of verifying the identity of a user or system**. It answers the question, 
**"Who are you?"** The goal is to ensure that the person or system attempting to access resources is indeed who they claim to be.

Common authentication methods include:
- **Passwords**: The most basic form, where users enter a secret word or phrase.
- **Multi-Factor Authentication (MFA)**: Combines two or more authentication factors (e.g., something you know, something you have, something you are) to increase security.
- **Biometrics**: Uses physical characteristics like fingerprints, facial recognition, or retina scans.
- **OAuth/OpenID Connect**: Tokens are used to authenticate users in web applications and APIs.

**2. Authorization** occurs after authentication and **determines what an authenticated user or system is allowed to do**. It answers the question, **"What can you do?"** This step ensures that users have the appropriate permissions to access specific resources or perform certain actions.

Common approaches to authorization include:
- **Role-Based Access Control (RBAC)**: Users are assigned roles, and permissions are granted based on those roles.
- **Access Control Lists (ACLs)**: Permissions are tied to specific resources, with a list specifying who can access each resource.
- **OAuth Scopes**: Define what resources an authenticated token can access in web services.
- **Attribute-Based Access Control (ABAC)**: Policies are defined based on attributes of the user, resource, and environment (e.g., time of day).

***How They Work Together***
1. **Authentication** happens first to confirm the identity of the user.
2. Once authenticated, **authorization** kicks in to determine what resources the user has permission to access.

For example, in a web application:
- **Authentication** ensures the user logging in with a username and password is legitimate.
- **Authorization** checks whether the authenticated user has the rights to view or modify specific data within the application.

Both authentication and authorization are critical for ensuring the security and integrity of software systems.


---
### Authentication and Authorization Sample

![auth plan sample](./img/0-auth-plan-sample.png)

***Spring Security***

**1. Load Spring Security Dependency**: Include security dependency <code>implementation 'org.springframework.boot:spring-boot-starter-security'</code>
**automatically enables the login/wall Page that requires user and password** autogenerated by default -it changes everytime the app is restarted until proper configuration-, 
that can be seen in the console during startup, e.g. of **default account user**:
```text
// console output:
2024-09-04T19:21:27.345-03:00  WARN 3932 --- [sec] [           main] .s.s.UserDetailsServiceAutoConfiguration : 

Using generated security password: 66647e02-aa82-4641-9d77-197aa4ced340

This generated password is for development use only. Your security configuration must be updated before running your application in production.
```
*Note logout page is also added* by default. 

**2. Enable Web Security Annotation**:  Add `@EnableWebSecurity` annotation inside a Configuration file. 
By default, when Spring Security is added into a project, web security is applied to all requests:
- It **enables Spring Security’s filters** and configuration for web applications.
- It **provides customization of security policies** by allowing developers **to configure authentication, authorization, and other security mechanisms**.
    ```java
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                // Cross-Site Request Forgery (CSRF) is a type of web security vulnerability that tricks a user’s browser
                // into performing actions they didn’t intend to perform on a different site.
                // This happens because the browser automatically includes credentials like cookies with each request,
                // allowing an attacker to exploit the trust a web application has in the user’s browser.
                // To avoid this CSRF protection is "enabled" by default in Spring Security, i.e.
                // disallowing calls from all suspicions address that don't belong to the company.
                // In this case we allow "localhost" because /registration will be performed from a ReST client app
                // that runs locally:
                .csrf(cnf -> cnf.csrfTokenRepository(new HttpSessionCsrfTokenRepository())
                        .requireCsrfProtectionMatcher(new RequestMatcher() {
                            @Override
                            public boolean matches(HttpServletRequest request) {
                                // Disable CSRF only for localhost:
                                var rh = request.getRemoteHost();
                                return !isValidHost(rh);
                            }
                        }))
                .authorizeHttpRequests(registry -> {
                    // avoid using regex like ^/welcome$ as requestMatchers by default does not use regex matching
                    // unless explicitly configured to do so.
                    // Instead, it performs ant-style matching (which uses * and ** wildcards, not regex).
                    registry.requestMatchers("/home", "/welcome", "/register/user").permitAll();
                    registry.requestMatchers("/admin/**").hasRole("admin");
                    registry.requestMatchers("/user/**").hasRole("user");
                    // this disables default Web Sec form login, i.e. wall including user and pass:
                    registry.anyRequest().authenticated();
                })
                // to enable Login form of Spring Web Sec -including Logout:
                //.formLogin(AbstractAuthenticationFilterConfigurer::permitAll)
                // (Note that customizing a Login page disables Logout already provided by Spring Web Sec).
                .formLogin(cnf -> cnf.loginPage("/login").successHandler(authSuccessMgr).permitAll())
                .build();
    }
    ```
`@EnableWebSecurity` is a meta-annotation that imports the necessary Spring Security configuration:
- With Spring Security 5.7+, the recommended way to configure security is through `SecurityFilterChain` beans instead of extending `WebSecurityConfigurerAdapter`.
- This setup **allows customization of authentication methods (e.g., basic auth, OAuth, JWT), password encoding, user roles, etc**.

**3. Load Users to Authenticate and Authorize**:  Create bean annotation with `UserDetailsService` interface inside a Configuration file.
The **UserDetailService objective is to load valid Users and theirs Roles** to compare
in order **to determine authentication and then authorization** of each potential user, e.g.:
```java
    private SysUserDetailsSvc sysUserDetailsSvc;

    /**
     * Once enabled it will stop showing auto-generated dev password by default in Spring console.
     * This service allows handling users.
     *
     * @return UserDetailsService
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //return loadUsersInMemory();
        return this.loadUsersFromDb();
    }

    private UserDetailsService loadUsersInMemory() {
        UserDetails normalUser = User.builder()
                .username("cami")
                // encoded password that can't be engineering reversed:
                .password("$2a$12$VoQJGEDrm4gdDy9tB/SsiuTrI98O.Z6NeIyhttiah7F6M3xq9ER7q")
                .roles("user")
                .build();
        UserDetails adminUser = User.builder()
                .username("male")
                // encoded password that can't be engineering reversed:
                .password("$2a$12$6pd9xnB3IK//QRfg/tJOteHRjgb74JLvkiIVRhRU.JdCeWf8uuEX2")
                .roles("admin", "user")
                .build();
        return new InMemoryUserDetailsManager(normalUser, adminUser);
    }

    private UserDetailsService loadUsersFromDb() {
        // reference to the service that loads all users available from DB into Spring Security:
        return sysUserDetailsSvc;
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        // Database Access Object Provider required for Setting Encoder at "Database Level":
        DaoAuthenticationProvider daoProvider = new DaoAuthenticationProvider();
        daoProvider.setPasswordEncoder(passwordEncoder());
        daoProvider.setUserDetailsService(sysUserDetailsSvc);
        return daoProvider;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```


***Password Encoders***
![password_encoder_comparison](./img/2-password-encoders.png?raw=true)
- Argon2 is the recommendation but is slower compared to others.


---
### JWT (JSON Web Token)
**JWTs** are **an open, industry standard RFC 7519 method for representing claims securely between two parties**. 
It is **commonly used for authentication and authorization in web applications**.

***Key Concepts***:

1. **Structure**:
    - A JWT is divided into three parts, separated by dots (`.`):
        1. **Header**: Contains metadata about the type of token and *the signing algorithm*.
        2. **Payload**: Contains the claims or statements about an entity (*typically, the user and its perms*) and additional data. This part is base64-encoded.
        3. **Signature**: Used to verify the token's integrity and authenticity. It's created by combining the encoded header, payload, and a *secret or private key*, then signing the result with a specified algorithm.

   Example JWT: `header.payload.signature`

2. **Usage**:
    - **Authentication**: After a user successfully logs in, a JWT is generated and sent to the client (usually in the response header). 
   The client stores the token (typically in local storage or a cookie) and sends it in subsequent requests to access protected resources.
    - **Authorization**: The server verifies the token's signature to ensure it has NOT been tampered with, 
   then extracts the user's identity and permissions from the payload to authorize access.

3. **Claims**:
*Claims are statements about an entity (typically the user and perms) and additional data*. 
These claims are *embedded in the payload section* of the JWT and are used to convey information between parties securely, e.g.
    - **Registered Claims**: Predefined claims like `iss` (issuer), `exp` (expiration time), `sub` (subject), and `aud` (audience).
    - **Public Claims**: Claims that can be defined by anyone, but they should be *registered in the IANA JSON Web Tokens Registry* to avoid collisions, e.g. `username` and `email`.
    - **Private Claims**: Custom claims created to share information between parties that agree on using them, e.g. `role` and `department`.

*Encoded JWT sample*:
```jwt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
*Decoded JWT*:
Header (ALGORITHM & TOKEN TYPE):
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
Payload (DATA):
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```
Verify Signature:
```text
HMACSHA256(
base64UrlEncode(header) + "." +
base64UrlEncode(payload),
⚠️"your-256-bit-secret" --> using "jwt.io" actually you can paste the secret here for verifying! i.e. to avoid tempering.
)
```

***Benefits***:
- **Stateless**: Since JWTs are self-contained, the server doesn’t need to store session data, making it scalable.
- **Compact**: The token is URL-safe and easy to pass around in HTTP headers.
- **Versatile**: JWTs can be used across different environments (web, mobile, IoT).

***Security Considerations***:
- **Signing**: Ensure the token is signed with a strong secret or private key using algorithms like `HS256` or `RS256`.
- **Expiration**: Set appropriate expiration times to limit the token's validity period.
- **HTTPS**: Always transmit JWTs over HTTPS to prevent interception.

JWTs are widely used in modern web applications for secure and efficient authentication and authorization.


---
### How JWT works in Spring
![How JWT works](./img/0-jwt-flow.png?raw=true)

When using JWTs (JSON Web Tokens) in a Spring-based server for authentication and authorization, the typical flow can be described as follows:

***User Authentication (Login)***:
- 1.a. **Client Request**: A client (e.g., a web app, mobile app) **sends** a POST request to the server’s `/login` or `/authenticate` endpoint with the **user's credentials (usually username and password)**.
- 2.a. **Server Verification**:
   - The Spring server receives the request and verifies the credentials against the user details stored in the database (or another user management service).
   - **If the credentials are valid, the server generates a JWT containing claims that identify the user and their roles or permissions**.
- 2.b. **JWT Creation**:
   - The server creates a JWT with:
      - **Header**: Specifies the signing algorithm (e.g., `HS256`).
      - **Payload**: Contains claims such as `sub` (subject, typically the username), `exp` (expiration time), and any custom claims (e.g., user roles).
      - **Signature**: The server **signs the token using a secret key or a private key**.
- 3.a. **Token Response**: The server sends the JWT back to the client, typically in the response body or as part of the response headers (e.g., `Authorization: Bearer <token>`).

***Subsequent Requests (Using JWT for Authorization)***:
- 4.a. **Client Request with JWT**:
   - For subsequent API requests, the client includes the JWT in the `Authorization` header: `Authorization: Bearer <token>`.
- 4.b. **Server Interception**:
   - The Spring server intercepts the request via a filter, typically a `JwtAuthenticationFilter` or similar.
- 4.c. **Token Validation**:
   - The filter extracts the JWT from the `Authorization` header and validates it.
   - Validation steps include:
      - Checking the token’s signature to ensure it hasn’t been tampered with.
      - Verifying the token’s expiration time (`exp` claim).
      - Ensuring the token was issued by a trusted source (`iss` claim).
      - Optionally verifying the audience (`aud` claim).
- 4.d. **Authentication Context**:
   - **If the token is valid, the server extracts user details (e.g., `sub`, `roles`)** from the token and sets the authentication context in Spring Security (`SecurityContextHolder`).
   - This context is used **to authorize access to secured endpoints based on roles or permissions**.
- 4.c. **Request Processing**:
   - The request is passed to the appropriate controller or handler method.
   - The server processes the request and returns the response to the client.

***Token Expiration and Refresh***:
- **Token Expiration**:
   - JWTs typically have an expiration time (`exp` claim). Once expired, the client cannot use the token to access protected resources.
- **Refresh Token** (Optional):
   - Some implementations use a separate refresh token mechanism.
   - The client can send a request to a `/refresh-token` endpoint with the refresh token.
   - If valid, the server issues a new JWT without requiring the user to log in again.

![JWT and secret](./img/1-jwt-secret-flow.png?raw=true)

***Workflow summary***:

In this flow, JWTs are used to securely manage user sessions without storing state on the server. The Spring server validates and processes each request based on the token provided by the client, ensuring secure and scalable authentication and authorization.


---
### How JWT works in Spring
1. Add necessary jjwt dependencies, i.e. including `jjwt-api, jjwt-impl, and jjwt-jackson` in `build.gradle`.


---
### Requirements
1. ⚠️Docker must be running before executing Application.
2. <code>docker-compose -f mysql.yml up -d</code> before running tests.
3. [Admirer URI](http://localhost:8081/) -⚠️Must pass **mysql** as **Server** and then username, password and database as established in properties.


---
### Further samples and useful links
- ***Forked Repository***
   
   [Reactive Programing, JWT, MSA and OAuth](https://github.com/paguerre3/Spring-Boot-Tutorials)

- ***JWT Validations***:
   
   [JWT IO](https://jwt.io/) to decode, verify and generate JWTs online.